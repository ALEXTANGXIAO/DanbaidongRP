#define NUMTHREAD_X 8
#define NUMTHREAD_Y 8

#include "Packages/com.unity.render-pipelines.danbaidong/ShaderLibrary/Core.hlsl"

//common SamplerState settings
SamplerState PointClampSampler;
SamplerState LinearClampSampler;

#pragma kernel GenerateSSShadowmap

RWTexture2D<float> _CustomMainLightSSShadowmapTex;
RWTexture2D<float> _MainLightShadowmapCacheTex;
Texture2D<float> _CameraDepthTexture;

float2 _SSShadowmapSize;
float2 _ShadowmapCacheSize;
uint _ShadowCascadeResolution;

#define MAX_SHADOW_CASCADES 8
float4      _CascadeShadowSplitSpheresArray[MAX_SHADOW_CASCADES];
float4x4    _MainLightWorldToShadow[MAX_SHADOW_CASCADES + 1];
float       _CascadeZDistanceArray[MAX_SHADOW_CASCADES];

float3 _LightDirection;

half ComputeCascadeIndex(float3 positionWS)
{

    float3 fromCenter0 = positionWS - _CascadeShadowSplitSpheresArray[0].xyz;
    float3 fromCenter1 = positionWS - _CascadeShadowSplitSpheresArray[1].xyz;
    float3 fromCenter2 = positionWS - _CascadeShadowSplitSpheresArray[2].xyz;
    float3 fromCenter3 = positionWS - _CascadeShadowSplitSpheresArray[3].xyz;
    float3 fromCenter4 = positionWS - _CascadeShadowSplitSpheresArray[4].xyz;
    float3 fromCenter5 = positionWS - _CascadeShadowSplitSpheresArray[5].xyz;
    float3 fromCenter6 = positionWS - _CascadeShadowSplitSpheresArray[6].xyz;
    float3 fromCenter7 = positionWS - _CascadeShadowSplitSpheresArray[7].xyz;

    float4 distClose = float4(dot(fromCenter0, fromCenter0), dot(fromCenter1, fromCenter1), dot(fromCenter2, fromCenter2), dot(fromCenter3, fromCenter3));
    float4 distFar = float4(dot(fromCenter4, fromCenter4), dot(fromCenter5, fromCenter5), dot(fromCenter6, fromCenter6), dot(fromCenter7, fromCenter7));

    float4 sphereBoundClose = float4(_CascadeShadowSplitSpheresArray[0].w
                                    ,_CascadeShadowSplitSpheresArray[1].w
                                    ,_CascadeShadowSplitSpheresArray[2].w
                                    ,_CascadeShadowSplitSpheresArray[3].w);
    float4 sphereBoundFar   = float4(_CascadeShadowSplitSpheresArray[4].w
                                    ,_CascadeShadowSplitSpheresArray[5].w
                                    ,_CascadeShadowSplitSpheresArray[6].w
                                    ,_CascadeShadowSplitSpheresArray[7].w);
    half4 weightsClose = half4(distClose < sphereBoundClose*sphereBoundClose);


    half4 weightsFar = half4(distFar < sphereBoundFar*sphereBoundFar);
    weightsFar.yzw = saturate(weightsFar.yzw - weightsFar.xyz);
    weightsFar.x = saturate(weightsFar.x - weightsClose.w);

    weightsClose.yzw = saturate(weightsClose.yzw - weightsClose.xyz);

    return 8 - dot(weightsClose, half4(8, 7, 6, 5)) - dot(weightsFar, half4(4, 3, 2, 1));

}

float4 TransformWorldToShadowCoord(float3 positionWS)
{
    half cascadeIndex = ComputeCascadeIndex(positionWS);


    float4 shadowCoord = mul(_MainLightWorldToShadow[cascadeIndex], float4(positionWS, 1.0));

    return float4(shadowCoord.xyz, cascadeIndex);
}

uint2 ConvertScreenUVToCascadeId(float2 screenUV, uint cascadeIndex)
{
    uint xOffset = (cascadeIndex % 2) * _ShadowCascadeResolution;
    uint yOffset = (cascadeIndex / 2) * _ShadowCascadeResolution;

    uint2 cascadeId = screenUV * _ShadowCascadeResolution;
    cascadeId.x += xOffset;
    cascadeId.y += yOffset;

    return cascadeId;
}

float BilinearSample(RWTexture2D<float> rwtexture, float2 uv)
{
    int u0 = floor(uv.x);
    int v0 = floor(uv.y);
    int u1 = u0 + 1;
    int v1 = v0 + 1;

    float xVal0 = lerp(rwtexture[int2(u0,v0)],rwtexture[int2(u1,v0)],uv.x - u0);
    float xVal1 = lerp(rwtexture[int2(u0,v1)],rwtexture[int2(u1,v1)],uv.x - u0);

    return lerp(xVal0, xVal1, uv.y - v0);
}




#define N_SAMPLE 64
static float2 poissonDisk[N_SAMPLE] = {
    float2(-0.5119625f, -0.4827938f),
    float2(-0.2171264f, -0.4768726f),
    float2(-0.7552931f, -0.2426507f),
    float2(-0.7136765f, -0.4496614f),
    float2(-0.5938849f, -0.6895654f),
    float2(-0.3148003f, -0.7047654f),
    float2(-0.42215f, -0.2024607f),
    float2(-0.9466816f, -0.2014508f),
    float2(-0.8409063f, -0.03465778f),
    float2(-0.6517572f, -0.07476326f),
    float2(-0.1041822f, -0.02521214f),
    float2(-0.3042712f, -0.02195431f),
    float2(-0.5082307f, 0.1079806f),
    float2(-0.08429877f, -0.2316298f),
    float2(-0.9879128f, 0.1113683f),
    float2(-0.3859636f, 0.3363545f),
    float2(-0.1925334f, 0.1787288f),
    float2(0.003256182f, 0.138135f),
    float2(-0.8706837f, 0.3010679f),
    float2(-0.6982038f, 0.1904326f),
    float2(0.1975043f, 0.2221317f),
    float2(0.1507788f, 0.4204168f),
    float2(0.3514056f, 0.09865579f),
    float2(0.1558783f, -0.08460935f),
    float2(-0.0684978f, 0.4461993f),
    float2(0.3780522f, 0.3478679f),
    float2(0.3956799f, -0.1469177f),
    float2(0.5838975f, 0.1054943f),
    float2(0.6155105f, 0.3245716f),
    float2(0.3928624f, -0.4417621f),
    float2(0.1749884f, -0.4202175f),
    float2(0.6813727f, -0.2424808f),
    float2(-0.6707711f, 0.4912741f),
    float2(0.0005130528f, -0.8058334f),
    float2(0.02703013f, -0.6010728f),
    float2(-0.1658188f, -0.9695674f),
    float2(0.4060591f, -0.7100726f),
    float2(0.7713396f, -0.4713659f),
    float2(0.573212f, -0.51544f),
    float2(-0.3448896f, -0.9046497f),
    float2(0.1268544f, -0.9874692f),
    float2(0.7418533f, -0.6667366f),
    float2(0.3492522f, 0.5924662f),
    float2(0.5679897f, 0.5343465f),
    float2(0.5663417f, 0.7708698f),
    float2(0.7375497f, 0.6691415f),
    float2(0.2271994f, -0.6163502f),
    float2(0.2312844f, 0.8725659f),
    float2(0.4216993f, 0.9002838f),
    float2(0.4262091f, -0.9013284f),
    float2(0.2001408f, -0.808381f),
    float2(0.149394f, 0.6650763f),
    float2(-0.09640376f, 0.9843736f),
    float2(0.7682328f, -0.07273844f),
    float2(0.04146584f, 0.8313184f),
    float2(0.9705266f, -0.1143304f),
    float2(0.9670017f, 0.1293385f),
    float2(0.9015037f, -0.3306949f),
    float2(-0.5085648f, 0.7534177f),
    float2(0.9055501f, 0.3758393f),
    float2(0.7599946f, 0.1809109f),
    float2(-0.2483695f, 0.7942952f),
    float2(-0.4241052f, 0.5581087f),
    float2(-0.1020106f, 0.6724468f)
};

float2 RotateVec2(float2 v, float angle)
{
    float s = sin(angle);
    float c = cos(angle);

    return float2(v.x*c+v.y*s, -v.x*s+v.y*c);
}


float2 SampleBlockerAvgDepth(float mDepth , float2 shadowCacheId, float searchWidth, float random)
{
    float blockDepth = 0;
    int count = 0.0001;

    for(int i = 0; i < N_SAMPLE; i++)
    {
        float2 offset = poissonDisk[i];
        offset = RotateVec2(offset, random);
        float2 UVOffsetID = shadowCacheId + offset * searchWidth;
        //UVOffsetID = clamp(UVOffsetID, 0, float2((_ShadowmapCacheSize.x-1), (_ShadowmapCacheSize.y-1)));
        float sampleDepth = BilinearSample(_MainLightShadowmapCacheTex, UVOffsetID);
        if(sampleDepth > mDepth)
        //if(1)
        {
            blockDepth += sampleDepth;
            count++;
        }
    }

    return float2(blockDepth/count , count);
}

float SampleShadowmapPCF(float mDepth , float2 shadowCacheId, float filterWidth, float cascadeIndex, float random)
{

    float shadowVal = 0.0;
    for(int i = 0; i < N_SAMPLE; i++)
    {
        float2 offset = poissonDisk[i];
        offset = RotateVec2(offset, random);
        float2 UVOffsetID = shadowCacheId + offset * filterWidth;
        //UVOffsetID = clamp(UVOffsetID, 0, float2((_ShadowmapCacheSize.x-1), (_ShadowmapCacheSize.y-1)));
        float sampleDepth = BilinearSample(_MainLightShadowmapCacheTex, UVOffsetID);
        if(sampleDepth < mDepth)
        {
            shadowVal += 1.0;
        }
    }
    return shadowVal / N_SAMPLE;

}

float Random1DTo1D(float value,float a,float b){
    //make value more random by making it bigger
    float random = frac(sin(value+b)*a);
        return random;
}


#define BLUR_SIZE 5
#define GAUSSIAN_WEIGHT_SIZE 3
float gaussianWeight[GAUSSIAN_WEIGHT_SIZE] = {0.4026, 0.2442, 0.0545};

[numthreads(NUMTHREAD_X,NUMTHREAD_Y,1)]
void GenerateSSShadowmap (uint3 id : SV_DispatchThreadID)
{

    
    if(id.x < _SSShadowmapSize.x && id.y < _SSShadowmapSize.y)
    {
        float2 screenUV = float2(id.x / (_SSShadowmapSize.x-1), id.y / (_SSShadowmapSize.y-1)); 

        float inputPixelRawDepth = _CameraDepthTexture.SampleLevel(PointClampSampler, screenUV, 0);

        //Skybox area
        #if UNITY_REVERSED_Z
            if(inputPixelRawDepth == 0.0)
            {
                _CustomMainLightSSShadowmapTex[id.xy] = 1;
                return;
            }  
        #else
            if(inputPixelRawDepth == 1.0)
            {
                _CustomMainLightSSShadowmapTex[id.xy] = 1;
                return;
            }
        #endif

        float4 positionCS = float4(screenUV * 2.0 - 1.0, inputPixelRawDepth, 1.0);
        #if UNITY_UV_STARTS_AT_TOP
            positionCS.y = -positionCS.y;
        #endif
        
        float4 positionHWS = mul(UNITY_MATRIX_I_VP, positionCS);
        float3 positionWS = positionHWS.xyz / positionHWS.w;


        float4 shadowCoord = TransformWorldToShadowCoord(positionWS);
        uint cascadeIndex = shadowCoord.w;
        float mDepthLS = shadowCoord.z;

        float2 shadowCacheUVId = shadowCoord.xy * (_ShadowmapCacheSize.xy - 1);
        
        float3 lightDir1 = normalize(_MainLightPosition.xyz);
        float tan1 = lightDir1.y / sqrt(1 - lightDir1.y * lightDir1.y + 0.0001);

        float neighborDepthLS = 0;
        float texelSizeWS = _CascadeShadowSplitSpheresArray[cascadeIndex].w / 512;
        for (int i = -1; i <= 1; i++)
        {
            for (int j = -1; j <= 1; j++)
            {
                float2 offsetID = 0.2 * int2(i, j) / texelSizeWS;
                float2 neighborShadowCacheUVID = shadowCacheUVId + offsetID;

                float deltaZ_WS = 0.2 / tan1;
                float deltaZ_LS = deltaZ_WS / _CascadeZDistanceArray[shadowCoord.w];

                neighborDepthLS += _MainLightShadowmapCacheTex[neighborShadowCacheUVID] < mDepthLS + deltaZ_LS;
            }
        }

        if(neighborDepthLS == 0)
        {
            _CustomMainLightSSShadowmapTex[id.xy] = 0;
            return;

        }
        else if(neighborDepthLS == 9)
        {
            _CustomMainLightSSShadowmapTex[id.xy] = 1;
            return;
        }


        float random = Random1DTo1D(positionWS.x + positionWS.y, 14375.5964, 0.546);
        float OrthHalfWidth = _CascadeShadowSplitSpheresArray[cascadeIndex].w;
        float OrthHalfWidth0 = _CascadeShadowSplitSpheresArray[0].w;
        float blockerSearchWidth = 20 * OrthHalfWidth0/OrthHalfWidth;

        float4 offsetShadowCoord = TransformWorldToShadowCoord(positionWS + (_LightDirection.xyz) * OrthHalfWidth/512);
        float3 lightDir = normalize(_MainLightPosition.xyz);
        float tan = lightDir.y / sqrt(1 - lightDir.y * lightDir.y + 0.0001);
        float texelSize = OrthHalfWidth/512;
        float deltaZ_WS = blockerSearchWidth * texelSize / tan;
        float deltaZ_LS = deltaZ_WS / _CascadeZDistanceArray[shadowCoord.w];

        float2 blocker = SampleBlockerAvgDepth(mDepthLS + deltaZ_LS, shadowCacheUVId, blockerSearchWidth, random);
        float blockerDepthLS = blocker.x;
        float blockerCount = blocker.y;
        
        if(blockerCount < 1.0)
        {
            //no block
            _CustomMainLightSSShadowmapTex[id.xy] = 1.0;
            
        }
        else
        {
            float banying = abs(mDepthLS - blockerDepthLS) * _CascadeZDistanceArray[cascadeIndex] / OrthHalfWidth;
            banying = min(banying*10 , 100/ OrthHalfWidth);

            deltaZ_WS = banying * texelSize / tan;
            deltaZ_LS = deltaZ_WS / _CascadeZDistanceArray[shadowCoord.w];

            _CustomMainLightSSShadowmapTex[id.xy] = SampleShadowmapPCF(mDepthLS + deltaZ_LS, shadowCacheUVId, banying, cascadeIndex, random);
        }

    }
    
}

