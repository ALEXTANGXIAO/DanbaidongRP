#define NUMTHREAD_X 8
#define NUMTHREAD_Y 8

#include "Packages/com.unity.render-pipelines.danbaidong/ShaderLibrary/Core.hlsl"

//common SamplerState settings
SamplerState PointClampSampler;
SamplerState LinearClampSampler;

#pragma kernel GenerateSSShadowmap

RWTexture2D<float> _CustomMainLightSSShadowmapTex;
RWTexture2D<float> _MainLightShadowmapCacheTex;
Texture2D<float> _CameraDepthTexture;

float2 _SSShadowmapSize;
float2 _ShadowmapCacheSize;
uint _ShadowCascadeResolution;

#define MAX_SHADOW_CASCADES 8
float4      _CascadeShadowSplitSpheresArray[MAX_SHADOW_CASCADES];
float4x4    _MainLightWorldToShadow[MAX_SHADOW_CASCADES + 1];
float       _CascadeZDistanceArray[MAX_SHADOW_CASCADES];

float3 _LightDirection;

half ComputeCascadeIndex(float3 positionWS)
{

    float3 fromCenter0 = positionWS - _CascadeShadowSplitSpheresArray[0].xyz;
    float3 fromCenter1 = positionWS - _CascadeShadowSplitSpheresArray[1].xyz;
    float3 fromCenter2 = positionWS - _CascadeShadowSplitSpheresArray[2].xyz;
    float3 fromCenter3 = positionWS - _CascadeShadowSplitSpheresArray[3].xyz;
    float3 fromCenter4 = positionWS - _CascadeShadowSplitSpheresArray[4].xyz;
    float3 fromCenter5 = positionWS - _CascadeShadowSplitSpheresArray[5].xyz;
    float3 fromCenter6 = positionWS - _CascadeShadowSplitSpheresArray[6].xyz;
    float3 fromCenter7 = positionWS - _CascadeShadowSplitSpheresArray[7].xyz;

    float4 distClose = float4(dot(fromCenter0, fromCenter0), dot(fromCenter1, fromCenter1), dot(fromCenter2, fromCenter2), dot(fromCenter3, fromCenter3));
    float4 distFar = float4(dot(fromCenter4, fromCenter4), dot(fromCenter5, fromCenter5), dot(fromCenter6, fromCenter6), dot(fromCenter7, fromCenter7));

    float4 sphereBoundClose = float4(_CascadeShadowSplitSpheresArray[0].w
                                    ,_CascadeShadowSplitSpheresArray[1].w
                                    ,_CascadeShadowSplitSpheresArray[2].w
                                    ,_CascadeShadowSplitSpheresArray[3].w);
    float4 sphereBoundFar   = float4(_CascadeShadowSplitSpheresArray[4].w
                                    ,_CascadeShadowSplitSpheresArray[5].w
                                    ,_CascadeShadowSplitSpheresArray[6].w
                                    ,_CascadeShadowSplitSpheresArray[7].w);
    half4 weightsClose = half4(distClose < sphereBoundClose*sphereBoundClose);


    half4 weightsFar = half4(distFar < sphereBoundFar*sphereBoundFar);
    weightsFar.yzw = saturate(weightsFar.yzw - weightsFar.xyz);
    weightsFar.x = saturate(weightsFar.x - weightsClose.w);

    weightsClose.yzw = saturate(weightsClose.yzw - weightsClose.xyz);

    return 8 - dot(weightsClose, half4(8, 7, 6, 5)) - dot(weightsFar, half4(4, 3, 2, 1));

}

float4 TransformWorldToShadowCoord(float3 positionWS)
{
    half cascadeIndex = ComputeCascadeIndex(positionWS);


    float4 shadowCoord = mul(_MainLightWorldToShadow[cascadeIndex], float4(positionWS, 1.0));

    return float4(shadowCoord.xyz, cascadeIndex);
}

uint2 ConvertScreenUVToCascadeId(float2 screenUV, uint cascadeIndex)
{
    uint xOffset = (cascadeIndex % 2) * _ShadowCascadeResolution;
    uint yOffset = (cascadeIndex / 2) * _ShadowCascadeResolution;

    uint2 cascadeId = screenUV * _ShadowCascadeResolution;
    cascadeId.x += xOffset;
    cascadeId.y += yOffset;

    return cascadeId;
}

float BilinearSample(RWTexture2D<float> rwtexture, float2 uv)
{
    int u0 = floor(uv.x);
    int v0 = floor(uv.y);
    int u1 = u0 + 1;
    int v1 = v0 + 1;

    float xVal0 = lerp(rwtexture[int2(u0,v0)],rwtexture[int2(u1,v0)],uv.x - u0);
    float xVal1 = lerp(rwtexture[int2(u0,v1)],rwtexture[int2(u1,v1)],uv.x - u0);

    return lerp(xVal0, xVal1, uv.y - v0);
}




// #define N_SAMPLE 64
// static float2 poissonDisk[N_SAMPLE] = {
//     float2(-0.5119625f, -0.4827938f),
//     float2(-0.2171264f, -0.4768726f),
//     float2(-0.7552931f, -0.2426507f),
//     float2(-0.7136765f, -0.4496614f),
//     float2(-0.5938849f, -0.6895654f),
//     float2(-0.3148003f, -0.7047654f),
//     float2(-0.42215f, -0.2024607f),
//     float2(-0.9466816f, -0.2014508f),
//     float2(-0.8409063f, -0.03465778f),
//     float2(-0.6517572f, -0.07476326f),
//     float2(-0.1041822f, -0.02521214f),
//     float2(-0.3042712f, -0.02195431f),
//     float2(-0.5082307f, 0.1079806f),
//     float2(-0.08429877f, -0.2316298f),
//     float2(-0.9879128f, 0.1113683f),
//     float2(-0.3859636f, 0.3363545f),
//     float2(-0.1925334f, 0.1787288f),
//     float2(0.003256182f, 0.138135f),
//     float2(-0.8706837f, 0.3010679f),
//     float2(-0.6982038f, 0.1904326f),
//     float2(0.1975043f, 0.2221317f),
//     float2(0.1507788f, 0.4204168f),
//     float2(0.3514056f, 0.09865579f),
//     float2(0.1558783f, -0.08460935f),
//     float2(-0.0684978f, 0.4461993f),
//     float2(0.3780522f, 0.3478679f),
//     float2(0.3956799f, -0.1469177f),
//     float2(0.5838975f, 0.1054943f),
//     float2(0.6155105f, 0.3245716f),
//     float2(0.3928624f, -0.4417621f),
//     float2(0.1749884f, -0.4202175f),
//     float2(0.6813727f, -0.2424808f),
//     float2(-0.6707711f, 0.4912741f),
//     float2(0.0005130528f, -0.8058334f),
//     float2(0.02703013f, -0.6010728f),
//     float2(-0.1658188f, -0.9695674f),
//     float2(0.4060591f, -0.7100726f),
//     float2(0.7713396f, -0.4713659f),
//     float2(0.573212f, -0.51544f),
//     float2(-0.3448896f, -0.9046497f),
//     float2(0.1268544f, -0.9874692f),
//     float2(0.7418533f, -0.6667366f),
//     float2(0.3492522f, 0.5924662f),
//     float2(0.5679897f, 0.5343465f),
//     float2(0.5663417f, 0.7708698f),
//     float2(0.7375497f, 0.6691415f),
//     float2(0.2271994f, -0.6163502f),
//     float2(0.2312844f, 0.8725659f),
//     float2(0.4216993f, 0.9002838f),
//     float2(0.4262091f, -0.9013284f),
//     float2(0.2001408f, -0.808381f),
//     float2(0.149394f, 0.6650763f),
//     float2(-0.09640376f, 0.9843736f),
//     float2(0.7682328f, -0.07273844f),
//     float2(0.04146584f, 0.8313184f),
//     float2(0.9705266f, -0.1143304f),
//     float2(0.9670017f, 0.1293385f),
//     float2(0.9015037f, -0.3306949f),
//     float2(-0.5085648f, 0.7534177f),
//     float2(0.9055501f, 0.3758393f),
//     float2(0.7599946f, 0.1809109f),
//     float2(-0.2483695f, 0.7942952f),
//     float2(-0.4241052f, 0.5581087f),
//     float2(-0.1020106f, 0.6724468f)
// };

//32 Samples
#define N_SAMPLE 32
static float2 poissonDisk[N_SAMPLE] = {
    float2(0.4481053f, 0.4656063f),
    float2(0.109845f, 0.3884785f),
    float2(0.925029f, 0.299504f),
    float2(0.756192f, 0.5476846f),
    float2(0.5795485f, 0.1430717f),
    float2(0.2469418f, 0.6718715f),
    float2(0.1236043f, 0.0953531f),
    float2(-0.1965252f, 0.6202642f),
    float2(-0.05442613f, 0.88547f),
    float2(0.2118312f, 0.9747477f),
    float2(0.5822455f, -0.1843866f),
    float2(0.9967672f, -0.0458946f),
    float2(-0.5726921f, 0.5182314f),
    float2(-0.3549153f, 0.8723631f),
    float2(-0.213845f, 0.263582f),
    float2(0.5040107f, 0.8283719f),
    float2(-0.2624803f, -0.03808399f),
    float2(-0.064064f, -0.3815505f),
    float2(0.229777f, -0.1724686f),
    float2(-0.555498f, 0.1559999f),
    float2(0.6732352f, -0.4522001f),
    float2(0.1673856f, -0.6102839f),
    float2(0.424861f, -0.8872398f),
    float2(0.3916395f, -0.432821f),
    float2(0.941745f, -0.321401f),
    float2(-0.04789525f, -0.7901476f),
    float2(-0.8741811f, -0.04579748f),
    float2(-0.7191507f, -0.3286511f),
    float2(-0.8806899f, 0.3031786f),
    float2(-0.3485192f, -0.3236777f),
    float2(-0.4746883f, -0.6023529f),
    float2(-0.4106881f, -0.8818545f)
};

#define N_SAMPLE_SMALL 16
static float2 poissonDisk_small[16] = {
    float2( -0.94201624, -0.39906216 ),
    float2( 0.94558609, -0.76890725 ),
    float2( -0.094184101, -0.92938870 ),
    float2( 0.34495938, 0.29387760 ),
    float2( -0.91588581, 0.45771432 ),
    float2( -0.81544232, -0.87912464 ),
    float2( -0.38277543, 0.27676845 ),
    float2( 0.97484398, 0.75648379 ),
    float2( 0.44323325, -0.97511554 ),
    float2( 0.53742981, -0.47373420 ),
    float2( -0.26496911, -0.41893023 ),
    float2( 0.79197514, 0.19090188 ),
    float2( -0.24188840, 0.99706507 ),
    float2( -0.81409955, 0.91437590 ),
    float2( 0.19984126, 0.78641367 ),
    float2( 0.14383161, -0.14100790 )
};

float2 RotateVec2(float2 v, float angle)
{
    float s = sin(angle);
    float c = cos(angle);

    return float2(v.x*c+v.y*s, -v.x*s+v.y*c);
}


float2 SampleBlockerAvgDepth(float mDepth , float2 shadowCacheId, float searchWidth, float random)
{
    float blockDepth = 0;
    int count = 0.0001;

    for(int i = 0; i < N_SAMPLE; i++)
    {
        float2 offset = poissonDisk[i];
        offset = RotateVec2(offset, random);
        float2 UVOffsetID = shadowCacheId + offset * searchWidth;
        //UVOffsetID = clamp(UVOffsetID, 0, float2((_ShadowmapCacheSize.x-1), (_ShadowmapCacheSize.y-1)));
        float sampleDepth = BilinearSample(_MainLightShadowmapCacheTex, UVOffsetID);
        if(sampleDepth > mDepth)
        //if(1)
        {
            blockDepth += sampleDepth;
            count++;
        }
    }

    return float2(blockDepth/count , count);
}

float SampleShadowmapPCF(float mDepth , float2 shadowCacheId, float filterWidth, float cascadeIndex, float random)
{

    float shadowVal = 0.0;
    for(int i = 0; i < N_SAMPLE; i++)
    {
        float2 offset = poissonDisk[i];
        offset = RotateVec2(offset, random);
        float2 UVOffsetID = shadowCacheId + offset * filterWidth;
        //UVOffsetID = clamp(UVOffsetID, 0, float2((_ShadowmapCacheSize.x-1), (_ShadowmapCacheSize.y-1)));
        float sampleDepth = BilinearSample(_MainLightShadowmapCacheTex, UVOffsetID);
        if(sampleDepth < mDepth)
        {
            shadowVal += 1.0;
        }
    }
    return shadowVal / N_SAMPLE;

}

float2 SampleBlockerAvgDepthSmall(float mDepth , float2 shadowCacheId, float searchWidth, float random)
{
    float blockDepth = 0;
    int count = 0.0001;

    for(int i = 0; i < N_SAMPLE_SMALL; i++)
    {
        float2 offset = poissonDisk_small[i];
        offset = RotateVec2(offset, random);
        float2 UVOffsetID = shadowCacheId + offset * searchWidth;
        //UVOffsetID = clamp(UVOffsetID, 0, float2((_ShadowmapCacheSize.x-1), (_ShadowmapCacheSize.y-1)));
        float sampleDepth = BilinearSample(_MainLightShadowmapCacheTex, UVOffsetID);
        if(sampleDepth > mDepth)
        //if(1)
        {
            blockDepth += sampleDepth;
            count++;
        }
    }

    return float2(blockDepth/count , count);
}

// float SampleShadowmapPCFSmall(float mDepth , float2 shadowCacheId, float filterWidth, float cascadeIndex, float random)
// {

//     float shadowVal = 0.0;
//     for(int i = 0; i < N_SAMPLE_SMALL; i++)
//     {
//         float2 offset = poissonDisk_small[i];
//         offset = RotateVec2(offset, random);
//         float2 UVOffsetID = shadowCacheId + offset * filterWidth;
//         //UVOffsetID = clamp(UVOffsetID, 0, float2((_ShadowmapCacheSize.x-1), (_ShadowmapCacheSize.y-1)));
//         float sampleDepth = BilinearSample(_MainLightShadowmapCacheTex, UVOffsetID);
//         if(sampleDepth < mDepth)
//         {
//             shadowVal += 1.0;
//         }
//     }
//     return shadowVal / N_SAMPLE_SMALL;

// }
float Random1DTo1D(float value,float a,float b){
    //make value more random by making it bigger
    float random = frac(sin(value+b)*a);
        return random;
}


#define BLUR_SIZE 5
#define GAUSSIAN_WEIGHT_SIZE 3
float gaussianWeight[GAUSSIAN_WEIGHT_SIZE] = {0.4026, 0.2442, 0.0545};

[numthreads(NUMTHREAD_X,NUMTHREAD_Y,1)]
void GenerateSSShadowmap (uint3 id : SV_DispatchThreadID)
{

    
    if(id.x < _SSShadowmapSize.x && id.y < _SSShadowmapSize.y)
    {
        float2 screenUV = float2(id.x / (_SSShadowmapSize.x-1), id.y / (_SSShadowmapSize.y-1)); 

        float inputPixelRawDepth = _CameraDepthTexture.SampleLevel(PointClampSampler, screenUV, 0);

        //Skybox area
        #if UNITY_REVERSED_Z
            if(inputPixelRawDepth == 0.0)
            {
                _CustomMainLightSSShadowmapTex[id.xy] = 1;
                return;
            }  
        #else
            if(inputPixelRawDepth == 1.0)
            {
                _CustomMainLightSSShadowmapTex[id.xy] = 1;
                return;
            }
        #endif

        float4 positionCS = float4(screenUV * 2.0 - 1.0, inputPixelRawDepth, 1.0);
        #if UNITY_UV_STARTS_AT_TOP
            positionCS.y = -positionCS.y;
        #endif
        
        float4 positionHWS = mul(UNITY_MATRIX_I_VP, positionCS);
        float3 positionWS = positionHWS.xyz / positionHWS.w;


        float4 shadowCoord = TransformWorldToShadowCoord(positionWS);
        uint cascadeIndex = shadowCoord.w;
        float mDepthLS = shadowCoord.z;

        float2 shadowCacheUVId = shadowCoord.xy * (_ShadowmapCacheSize.xy - 1);
        
        float3 lightDir1 = normalize(_MainLightPosition.xyz);
        float tan1 = lightDir1.y / sqrt(1 - lightDir1.y * lightDir1.y + 0.0001);

        float neighborDepthLS = 0;
        float texelSizeWS = _CascadeShadowSplitSpheresArray[cascadeIndex].w / 512;
        for (int i = -1; i <= 1; i++)
        {
            for (int j = -1; j <= 1; j++)
            {
                float2 offsetID = 0.2 * int2(i, j) / texelSizeWS;
                float2 neighborShadowCacheUVID = shadowCacheUVId + offsetID;

                float deltaZ_WS = 0.2 / tan1;
                float deltaZ_LS = deltaZ_WS / _CascadeZDistanceArray[shadowCoord.w];

                neighborDepthLS += _MainLightShadowmapCacheTex[neighborShadowCacheUVID] < mDepthLS + deltaZ_LS;
            }
        }


        // if(neighborDepthLS == 0)
        // {
        //     _CustomMainLightSSShadowmapTex[id.xy] = 0;
        //     return;

        // }
        // else if(neighborDepthLS == 9)
        // {
        //     _CustomMainLightSSShadowmapTex[id.xy] = 1;
        //     return;
        // }



        // float random_pre = Random1DTo1D(positionWS.x + positionWS.y, 14375.5964, 0.546);
        // float OrthHalfWidth_pre = _CascadeShadowSplitSpheresArray[cascadeIndex].w;
        // float OrthHalfWidth0_pre = _CascadeShadowSplitSpheresArray[0].w;
        // float blockerSearchWidth_pre = 20 * OrthHalfWidth0_pre/OrthHalfWidth_pre;

        // float4 offsetShadowCoord_pre = TransformWorldToShadowCoord(positionWS + (_LightDirection.xyz) * OrthHalfWidth_pre/512);
        // float3 lightDir_pre = normalize(_MainLightPosition.xyz);
        // float tan_pre = lightDir_pre.y / sqrt(1 - lightDir_pre.y * lightDir_pre.y + 0.0001);
        // float texelSize_pre = OrthHalfWidth_pre/512;
        // float deltaZ_WS_pre = blockerSearchWidth_pre * texelSize_pre / tan_pre;
        // float deltaZ_LS_pre = deltaZ_WS_pre / _CascadeZDistanceArray[shadowCoord.w];

        // float2 blocker_pre = SampleBlockerAvgDepthSmall(mDepthLS + deltaZ_LS_pre, shadowCacheUVId, blockerSearchWidth_pre, random_pre);
        // float blockerDepthLS_pre = blocker_pre.x;
        // float blockerCount_pre = blocker_pre.y;

        // if(blocker_pre.y == 0)
        // {
        //     _CustomMainLightSSShadowmapTex[id.xy] = 1;
        //     return;

        // }
        // else if(blocker_pre.y == N_SAMPLE_SMALL)
        // {
        //     _CustomMainLightSSShadowmapTex[id.xy] = 0;
        //     return;
        // }


        // _CustomMainLightSSShadowmapTex[id.xy] = 0.5;
        // return;



        float random = Random1DTo1D(positionWS.x + positionWS.y, 14375.5964, 0.546);
        float OrthHalfWidth = _CascadeShadowSplitSpheresArray[cascadeIndex].w;
        float OrthHalfWidth0 = _CascadeShadowSplitSpheresArray[0].w;
        float blockerSearchWidth = 20 * OrthHalfWidth0/OrthHalfWidth;

        float4 offsetShadowCoord = TransformWorldToShadowCoord(positionWS + (_LightDirection.xyz) * OrthHalfWidth/512);
        float3 lightDir = normalize(_MainLightPosition.xyz);
        float tan = lightDir.y / sqrt(1 - lightDir.y * lightDir.y + 0.0001);
        float texelSize = OrthHalfWidth/512;
        float deltaZ_WS = blockerSearchWidth * texelSize / tan;
        float deltaZ_LS = deltaZ_WS / _CascadeZDistanceArray[shadowCoord.w];

        float2 blocker_pre = SampleBlockerAvgDepthSmall(mDepthLS + deltaZ_LS, shadowCacheUVId, blockerSearchWidth, random);
        if(blocker_pre.y == 0)
        {
            _CustomMainLightSSShadowmapTex[id.xy] = 1;
            return;

        }
        else if(blocker_pre.y == N_SAMPLE_SMALL)
        {
            _CustomMainLightSSShadowmapTex[id.xy] = 0;
            return;
        }

        float2 blocker = SampleBlockerAvgDepth(mDepthLS + deltaZ_LS, shadowCacheUVId, blockerSearchWidth, random);
        float blockerDepthLS = blocker.x;
        float blockerCount = blocker.y;
        
        if(blockerCount < 1.0)
        {
            //no block
            _CustomMainLightSSShadowmapTex[id.xy] = 1.0;
            
        }
        else
        {
            float banying = abs(mDepthLS - blockerDepthLS) * _CascadeZDistanceArray[cascadeIndex] / OrthHalfWidth;
            banying = min(banying*7 , 100/ OrthHalfWidth);

            deltaZ_WS = banying * texelSize / tan;
            deltaZ_LS = deltaZ_WS / _CascadeZDistanceArray[shadowCoord.w];

            _CustomMainLightSSShadowmapTex[id.xy] = SampleShadowmapPCF(mDepthLS + deltaZ_LS, shadowCacheUVId, banying, cascadeIndex, random);
        }

    }
    
}

