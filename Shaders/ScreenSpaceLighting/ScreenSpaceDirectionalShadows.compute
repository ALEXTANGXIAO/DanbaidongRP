// Definitions
//--------------------------------------------------------------------------------------------------

// #pragma enable_d3d11_debug_symbols
#pragma kernel ShadowClassifyTiles      SHADOW_CLASSIFY_TILES
#pragma kernel ScreenSpaceShadowmap     SHADOW_PCSS                 PCSS_FILTER=ScreenSpaceShadowmap
#pragma kernel BilateralFilterH         SHADOW_BILATERAL_FILTER     BILATERAL_FILTER=BilateralFilterH
#pragma kernel BilateralFilterV         SHADOW_BILATERAL_FILTER     BILATERAL_FILTER=BilateralFilterV       FINAL_PASS

#pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN

//--------------------------------------------------------------------------------------------------
// Included headers
//--------------------------------------------------------------------------------------------------

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.danbaidong/Shaders/Utils/Deferred.hlsl"
#include "Packages/com.unity.render-pipelines.danbaidong/ShaderLibrary/Core.hlsl"

#include "Packages/com.unity.render-pipelines.danbaidong/ShaderLibrary/Shadows.hlsl"
#include "Packages/com.unity.render-pipelines.danbaidong/ShaderLibrary/DeclareDepthTexture.hlsl"
#include "Packages/com.unity.render-pipelines.danbaidong/ShaderLibrary/GPUCulledLights.hlsl"

#include "Packages/com.unity.render-pipelines.danbaidong/Shaders/ScreenSpaceLighting/ScreenSpaceLighting.hlsl"

//--------------------------------------------------------------------------------------------------
// Inputs & outputs
//--------------------------------------------------------------------------------------------------

RWStructuredBuffer<uint> g_TileList;

#if defined(SHADOW_CLASSIFY_TILES)
TEXTURE2D_ARRAY(_DirShadowmapTexture);

RW_TEXTURE2D(float, _SSDirShadowmapTexture);
RWBuffer<uint> g_DispatchIndirectBuffer;


#elif defined(SHADOW_PCSS)
TEXTURE2D_ARRAY(_DirShadowmapTexture);

RW_TEXTURE2D(float, _PCSSTexture);


#elif defined(SHADOW_BILATERAL_FILTER)
TEXTURE2D_X_FLOAT(_GBuffer2);

RW_TEXTURE2D(float, _BilateralTexture);

#endif

//--------------------------------------------------------------------------------------------------
// Helpers
//--------------------------------------------------------------------------------------------------

#define SCREENSPACE_SHADOWS_TILE_SIZE   (16)
#define SCREENSPACE_SHADOWS_GROUP_SIZE  (SCREENSPACE_SHADOWS_TILE_SIZE / 2)
#define SCREENSPACE_SHADOWS_THREADS     (64)


#define PREFILTER_SAMPLE_COUNT          (16)
#define BLOCKER_SAMPLE_COUNT            (16)
#define PCSS_SAMPLE_COUNT               (32)

// World space filter size.
#define FILTER_SIZE_PREFILTER           (0.4)
#define FILTER_SIZE_BLOCKER             (0.2)

#define DIR_LIGHT_PENUMBRA_WIDTH        _DirLightShadowPenumbraParams.x





uint2 DecodeTileIndex(uint encoded)
{
    return uint2((encoded >> TILE_INDEX_SHIFT_X) & TILE_INDEX_MASK, (encoded >> TILE_INDEX_SHIFT_Y) & TILE_INDEX_MASK);
}

uint EncodeTileIndex(uint2 tileID)
{
    return (unity_StereoEyeIndex << TILE_INDEX_SHIFT_EYE) | (tileID.y << TILE_INDEX_SHIFT_Y) | (tileID.x << TILE_INDEX_SHIFT_X);
}

void InitializeDispatchThreadIdFromTileList(uint groupId, uint2 gThreadId, out uint2 tileCoord, out uint2 dThreadId)
{
    uint encodedTileIndex = g_TileList[groupId / 4];

    tileCoord = DecodeTileIndex(encodedTileIndex);
    dThreadId = tileCoord * SCREENSPACE_SHADOWS_TILE_SIZE
              + uint2(groupId & 1, (groupId >> 1) & 1) * SCREENSPACE_SHADOWS_GROUP_SIZE
              + gThreadId;
}

#if defined(SHADOW_CLASSIFY_TILES) || defined(SHADOW_PCSS)

// Limitation:
// Note that in cascade shadows, all occluders behind the near plane will get clamped to the near plane
// This will lead to the closest blocker sometimes being reported as much closer to the receiver than it really is
#if UNITY_REVERSED_Z
#define Z_OFFSET_DIRECTION 1
#else
#define Z_OFFSET_DIRECTION (-1)
#endif


#define DISK_SAMPLE_COUNT 64
// Fibonacci Spiral Disk Sampling Pattern
// https://people.irisa.fr/Ricardo.Marques/articles/2013/SF_CGF.pdf
//
// Normalized direction vector portion of fibonacci spiral can be baked into a LUT, regardless of sampleCount.
// This allows us to treat the directions as a progressive sequence, using any sampleCount in range [0, n <= LUT_LENGTH]
// the radius portion of spiral construction is coupled to sample count, but is fairly cheap to compute at runtime per sample.
// Generated (in javascript) with:
// var res = "";
// for (var i = 0; i < 64; ++i)
// {
//     var a = Math.PI * (3.0 - Math.sqrt(5.0));
//     var b = a / (2.0 * Math.PI);
//     var c = i * b;
//     var theta = (c - Math.floor(c)) * 2.0 * Math.PI;
//     res += "float2 (" + Math.cos(theta) + ", " + Math.sin(theta) + "),\n";
// }

static const float2 fibonacciSpiralDirection[DISK_SAMPLE_COUNT] =
{
    float2 (1, 0),
    float2 (-0.7373688780783197, 0.6754902942615238),
    float2 (0.08742572471695988, -0.9961710408648278),
    float2 (0.6084388609788625, 0.793600751291696),
    float2 (-0.9847134853154288, -0.174181950379311),
    float2 (0.8437552948123969, -0.5367280526263233),
    float2 (-0.25960430490148884, 0.9657150743757782),
    float2 (-0.46090702471337114, -0.8874484292452536),
    float2 (0.9393212963241182, 0.3430386308741014),
    float2 (-0.924345556137805, 0.3815564084749356),
    float2 (0.423845995047909, -0.9057342725556143),
    float2 (0.29928386444487326, 0.9541641203078969),
    float2 (-0.8652112097532296, -0.501407581232427),
    float2 (0.9766757736281757, -0.21471942904125949),
    float2 (-0.5751294291397363, 0.8180624302199686),
    float2 (-0.12851068979899202, -0.9917081236973847),
    float2 (0.764648995456044, 0.6444469828838233),
    float2 (-0.9991460540072823, 0.04131782619737919),
    float2 (0.7088294143034162, -0.7053799411794157),
    float2 (-0.04619144594036213, 0.9989326054954552),
    float2 (-0.6407091449636957, -0.7677836880006569),
    float2 (0.9910694127331615, 0.1333469877603031),
    float2 (-0.8208583369658855, 0.5711318504807807),
    float2 (0.21948136924637865, -0.9756166914079191),
    float2 (0.4971808749652937, 0.8676469198750981),
    float2 (-0.952692777196691, -0.30393498034490235),
    float2 (0.9077911335843911, -0.4194225289437443),
    float2 (-0.38606108220444624, 0.9224732195609431),
    float2 (-0.338452279474802, -0.9409835569861519),
    float2 (0.8851894374032159, 0.4652307598491077),
    float2 (-0.9669700052147743, 0.25489019011123065),
    float2 (0.5408377383579945, -0.8411269468800827),
    float2 (0.16937617250387435, 0.9855514761735877),
    float2 (-0.7906231749427578, -0.6123030256690173),
    float2 (0.9965856744766464, -0.08256508601054027),
    float2 (-0.6790793464527829, 0.7340648753490806),
    float2 (0.0048782771634473775, -0.9999881011351668),
    float2 (0.6718851669348499, 0.7406553331023337),
    float2 (-0.9957327006438772, -0.09228428288961682),
    float2 (0.7965594417444921, -0.6045602168251754),
    float2 (-0.17898358311978044, 0.9838520605119474),
    float2 (-0.5326055939855515, -0.8463635632843003),
    float2 (0.9644371617105072, 0.26431224169867934),
    float2 (-0.8896863018294744, 0.4565723210368687),
    float2 (0.34761681873279826, -0.9376366819478048),
    float2 (0.3770426545691533, 0.9261958953890079),
    float2 (-0.9036558571074695, -0.4282593745796637),
    float2 (0.9556127564793071, -0.2946256262683552),
    float2 (-0.50562235513749, 0.8627549095688868),
    float2 (-0.2099523790012021, -0.9777116131824024),
    float2 (0.8152470554454873, 0.5791133210240138),
    float2 (-0.9923232342597708, 0.12367133357503751),
    float2 (0.6481694844288681, -0.7614961060013474),
    float2 (0.036443223183926, 0.9993357251114194),
    float2 (-0.7019136816142636, -0.7122620188966349),
    float2 (0.998695384655528, 0.05106396643179117),
    float2 (-0.7709001090366207, 0.6369560596205411),
    float2 (0.13818011236605823, -0.9904071165669719),
    float2 (0.5671206801804437, 0.8236347091470047),
    float2 (-0.9745343917253847, -0.22423808629319533),
    float2 (0.8700619819701214, -0.49294233692210304),
    float2 (-0.30857886328244405, 0.9511987621603146),
    float2 (-0.4149890815356195, -0.9098263912451776),
    float2 (0.9205789302157817, 0.3905565685566777)
};

float2 ComputeFibonacciSpiralDiskSample(const in int sampleIndex, const in float diskRadius, const in float sampleCountInverse, const in float sampleCountBias)
{
    float sampleRadius = diskRadius * sqrt((float)sampleIndex * sampleCountInverse + sampleCountBias);
    float2 sampleDirection = fibonacciSpiralDirection[sampleIndex];
    return sampleDirection * sampleRadius;
}

// Samples non-uniformly spread across the disk kernel
float2 ComputeFibonacciSpiralDiskSampleClumped_Directional(const in int sampleIndex, const in float sampleCountInverse, const in float clumpExponent, out float sampleDistNorm)
{
    // Samples biased away from the center, so that sample 0 doesn't fall at (0, 0), or it will not be affected by sample jitter and create a visible edge.
    sampleDistNorm = (float)sampleIndex * sampleCountInverse;

    // non-uniform distribution when clumpExponent != 0.5
    // More samples in the middle
    sampleDistNorm = PositivePow(sampleDistNorm, clumpExponent);

    return fibonacciSpiralDirection[sampleIndex] * sampleDistNorm;
}

// Samples uniformly spread across the disk kernel
float2 ComputeFibonacciSpiralDiskSampleUniform_Directional(const in int sampleIndex, const in float sampleCountInverse, const in float sampleBias, out float sampleDistNorm)
{
    // Samples biased away from the center, so that sample 0 doesn't fall at (0, 0), or it will not be affected by sample jitter and create a visible edge.
    sampleDistNorm = (float)sampleIndex * sampleCountInverse + sampleBias;

    // sqrt results in uniform distribution
    sampleDistNorm = sqrt(sampleDistNorm);

    return fibonacciSpiralDirection[sampleIndex] * sampleDistNorm;
}

// PreFilter finds the border of shadows. 
float PreFilterSearch(float sampleCount, float filterSize, float3 shadowCoord, float cascadeIndex)
{
    float numBlockers = 0.0;

    float radial2ShadowmapDepth = _PerCascadePCSSData[cascadeIndex].x;
    float texelSizeWS = _PerCascadePCSSData[cascadeIndex].y;
    float farToNear = _PerCascadePCSSData[cascadeIndex].z;
    float blockerInvTangent = _PerCascadePCSSData[cascadeIndex].w;

    float2 minCoord = _DirLightShadowUVMinMax.xy;
    float2 maxCoord = _DirLightShadowUVMinMax.zw;
    float sampleCountInverse = rcp((float)sampleCount);
    float sampleCountBias = 0.5 * sampleCountInverse;

    // kernel my be too large, and there can be no valid depth compare result.
    // we must calculate it again in later PCSS.
    float coordOutOfBoundCount = 0;

    for (int i = 1; i < sampleCount && i < DISK_SAMPLE_COUNT; i++)
    {
        float sampleRadius = sqrt((float)i * sampleCountInverse + sampleCountBias);
        float2 offset = fibonacciSpiralDirection[i] * sampleRadius;
        offset *= filterSize;
        offset *= _MainLightShadowmapSize.x; // coord to uv


        float2 sampleCoord = shadowCoord.xy + offset;

        float radialOffset = filterSize * sampleRadius * texelSizeWS;
        float zoffset = radialOffset / farToNear * blockerInvTangent;

        float depthLS = shadowCoord.z + (Z_OFFSET_DIRECTION) * zoffset;

        float shadowMapDepth = SAMPLE_TEXTURE2D_ARRAY_LOD(_DirShadowmapTexture, sampler_PointClamp, sampleCoord, cascadeIndex, 0).x;

        bool isOutOfCoord = any(sampleCoord < minCoord) || any(sampleCoord > maxCoord);
        if (!isOutOfCoord && COMPARE_DEVICE_DEPTH_CLOSER(shadowMapDepth, depthLS))
        {
            numBlockers += 1.0;
        }

        if (isOutOfCoord)
        {
            coordOutOfBoundCount++;
        }
    }

    // Out of bound, we must calculate it again in later PCSS.
    if (coordOutOfBoundCount > 0)
    {
        numBlockers = 1.0;
    }

    // We must cover zero offset.
    float shadowMapDepth = SAMPLE_TEXTURE2D_ARRAY_LOD(_DirShadowmapTexture, sampler_PointClamp, shadowCoord.xy, cascadeIndex, 0).x;
    if (!(any(shadowCoord.xy < minCoord) || any(shadowCoord.xy > maxCoord)) && 
        COMPARE_DEVICE_DEPTH_CLOSER(shadowMapDepth, shadowCoord.z))
    {
        numBlockers += 1.0;
    }

    return numBlockers;
}

// Return x:avgerage blocker depth, y:num blockers
float2 BlockerSearch(float sampleCount, float filterSize, float3 shadowCoord, float2 random, float cascadeIndex)
{
    float avgBlockerDepth = 0.0;
    float depthSum = 0.0;
    float numBlockers = 0.0;

    float radial2ShadowmapDepth = _PerCascadePCSSData[cascadeIndex].x;
    float texelSizeWS = _PerCascadePCSSData[cascadeIndex].y;
    float farToNear = _PerCascadePCSSData[cascadeIndex].z;
    float blockerInvTangent = _PerCascadePCSSData[cascadeIndex].w;

    float2 minCoord = _DirLightShadowUVMinMax.xy;
    float2 maxCoord = _DirLightShadowUVMinMax.zw;
    float sampleCountInverse = rcp((float)sampleCount);
    float sampleCountBias = 0.5 * sampleCountInverse;
    
    for (int i = 0; i < sampleCount && i < DISK_SAMPLE_COUNT; i++)
    {
        float sampleDistNorm;
        float2 offset = 0.0;
        offset = ComputeFibonacciSpiralDiskSampleUniform_Directional(i, sampleCountInverse, sampleCountBias, sampleDistNorm);
        offset = float2(offset.x *  random.y + offset.y * random.x,
                    offset.x * -random.x + offset.y * random.y);
        offset *= filterSize;
        offset *= _MainLightShadowmapSize.x; // coord to uv

        float2 sampleCoord = shadowCoord.xy + offset;

        float radialOffset = filterSize * sampleDistNorm * texelSizeWS;
        float zoffset = radialOffset / farToNear * blockerInvTangent;

        float depthLS = shadowCoord.z + (Z_OFFSET_DIRECTION) * zoffset;

        float shadowMapDepth = SAMPLE_TEXTURE2D_ARRAY_LOD(_DirShadowmapTexture, sampler_PointClamp, sampleCoord, cascadeIndex, 0).x;
        if (!(any(sampleCoord < minCoord) || any(sampleCoord > maxCoord)) && 
            COMPARE_DEVICE_DEPTH_CLOSER(shadowMapDepth, depthLS))
        {
            depthSum += shadowMapDepth;
            numBlockers += 1.0;
        }
    }

    if (numBlockers > 0.0)
    {
        avgBlockerDepth = depthSum / numBlockers;
    }

    return float2(avgBlockerDepth, numBlockers);
}

float PCSSFilter(float sampleCount, float filterSize, float3 shadowCoord, float2 random, float cascadeIndex, float maxPCSSoffset)
{
    float numBlockers = 0.0;
    float totalSamples = 0.0;

    float radial2ShadowmapDepth = _PerCascadePCSSData[cascadeIndex].x;
    float texelSizeWS = _PerCascadePCSSData[cascadeIndex].y;
    float farToNear = _PerCascadePCSSData[cascadeIndex].z;
    float blockerInvTangent = _PerCascadePCSSData[cascadeIndex].w;

    float2 minCoord = _DirLightShadowUVMinMax.xy;
    float2 maxCoord = _DirLightShadowUVMinMax.zw;
    float sampleCountInverse = rcp((float)sampleCount);
    float sampleCountBias = 0.5 * sampleCountInverse;

    for (int i = 0; i < sampleCount && i < DISK_SAMPLE_COUNT; i++)
    {
        float sampleDistNorm;
        float2 offset = 0.0;
        offset = ComputeFibonacciSpiralDiskSampleUniform_Directional(i, sampleCountInverse, sampleCountBias, sampleDistNorm);
        offset = float2(offset.x *  random.y + offset.y * random.x,
                    offset.x * -random.x + offset.y * random.y);
        offset *= filterSize;
        offset *= _MainLightShadowmapSize.x; // coord to uv

        float2 sampleCoord = shadowCoord.xy + offset;

        float radialOffset = filterSize * sampleDistNorm * texelSizeWS;
        float zoffset = radialOffset / farToNear * blockerInvTangent;

        float depthLS = shadowCoord.z + (Z_OFFSET_DIRECTION) * min(zoffset, maxPCSSoffset);

        if (!(any(sampleCoord < minCoord) || any(sampleCoord > maxCoord)))
        {
            float shadowSample = SAMPLE_TEXTURE2D_ARRAY_SHADOW(_DirShadowmapTexture, sampler_LinearClampCompare, float3(sampleCoord, depthLS), cascadeIndex).x;
            numBlockers += shadowSample;
            totalSamples++;
        }
    }

    return totalSamples > 0 ? numBlockers / totalSamples : 1.0;
}



#elif defined(SHADOW_BILATERAL_FILTER)


#endif

//--------------------------------------------------------------------------------------------------
// Implementation Classify Tiles
//--------------------------------------------------------------------------------------------------

#if defined(SHADOW_CLASSIFY_TILES)

groupshared uint gTileCount = 0;

// Dispatch size is 16*16 (tile size), each group has 64 threads, each thread handle 4 piexels.
[numthreads(SCREENSPACE_SHADOWS_THREADS, 1, 1)]
void ShadowClassifyTiles(uint3 dispatchThreadId : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint3 groupID : SV_GroupID)
{
    uint2 tileID = groupID.xy;
    bool needPenumbra = false;
    uint2 screenSize = _ScreenSize.xy;
    uint tilesNum;
    tilesNum = (screenSize.x + SCREENSPACE_SHADOWS_TILE_SIZE - 1) / SCREENSPACE_SHADOWS_TILE_SIZE;
    tilesNum *= (screenSize.y + SCREENSPACE_SHADOWS_TILE_SIZE - 1) / SCREENSPACE_SHADOWS_TILE_SIZE;

    uint2 coordBoundLL = SCREENSPACE_SHADOWS_TILE_SIZE * tileID;
    

    // Sampling shadows
    UNITY_UNROLL
    for (int i = 0; i < 4; i++)
    {
        int idx = i * SCREENSPACE_SHADOWS_THREADS + groupIndex;
        uint2 coordSS = min(uint2(coordBoundLL.x + (idx & 0xf), coordBoundLL.y + (idx >> 4)), uint2(screenSize.x - 1, screenSize.y - 1));

        // Check valid first. Reject the sky/background
        float depth = LoadSceneDepth(coordSS);
        if (depth == UNITY_RAW_FAR_CLIP_VALUE)
        {
            _SSDirShadowmapTexture[coordSS] = 1.0;
            continue;
        }

        // Position
        PositionInputs posInput = GetPositionInput(coordSS.xy, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V, uint2(0, 0));
        float3 positionWS = posInput.positionWS;
        float cascadeIndex = ComputeCascadeIndex(positionWS);
        float4 shadowCoord = mul(_MainLightWorldToShadow[cascadeIndex], float4(positionWS, 1.0));

        float radial2ShadowmapDepth = _PerCascadePCSSData[cascadeIndex].x;
        float texelSizeWS           = _PerCascadePCSSData[cascadeIndex].y;
        float farToNear             = _PerCascadePCSSData[cascadeIndex].z;
        float blockerInvTangent     = _PerCascadePCSSData[cascadeIndex].w;

        // PreFilter Search
        float preFilterSize = FILTER_SIZE_PREFILTER / texelSizeWS; // texel count
        preFilterSize = max(preFilterSize, 1.0);
        float preFilterRet = PreFilterSearch(PREFILTER_SAMPLE_COUNT, preFilterSize, shadowCoord.xyz, cascadeIndex);
        bool isOcclusion = preFilterRet > 0;
        if (isOcclusion && preFilterRet < PREFILTER_SAMPLE_COUNT)
        {
            needPenumbra = true;
        }
        if (isOcclusion)
        {
            _SSDirShadowmapTexture[coordSS] = (preFilterRet == PREFILTER_SAMPLE_COUNT) ? 0.0 : 0.5;
        }
    }

    // Set group shared.
    if (needPenumbra)
    {
        InterlockedAdd(gTileCount, 1);
    }

    GroupMemoryBarrierWithGroupSync();

    // Write per tile data.
    if (groupIndex == 0 && gTileCount > 0)
    {
        uint tileOffset = 0;
        uint prevGroupCnt;
        // We are filling up an indirect argument buffer for DispatchIndirect.
        // The buffer contains {groupCntX, groupCntY, groupCntZ} = {groupCnt, 0, 0}.
        // Current thread contorls 4 pixels.
        InterlockedAdd(g_DispatchIndirectBuffer[0], 4, prevGroupCnt);
        tileOffset = prevGroupCnt / 4; // 4x 8x8 groups per a 16x16 tile
        g_TileList[tileOffset] = EncodeTileIndex(tileID.xy);
    }

}

#elif defined(SHADOW_PCSS)
//--------------------------------------------------------------------------------------------------
// Implementation PCSS shadows
//--------------------------------------------------------------------------------------------------


[numthreads(SCREENSPACE_SHADOWS_GROUP_SIZE, SCREENSPACE_SHADOWS_GROUP_SIZE, 1)]
void PCSS_FILTER(uint3 dispatchThreadId : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID, uint groupId : SV_GroupID)
{
    uint2 coordSS;
    uint2 tileCoord;
    InitializeDispatchThreadIdFromTileList(groupId, groupThreadId, tileCoord, coordSS);

    if (_PCSSTexture[coordSS] == 0.0 || _PCSSTexture[coordSS] == 1.0)
        return;

    float2 screenUV = coordSS * _ScreenSize.zw + (0.5 * _ScreenSize.zw);
    float depth = LoadSceneDepth(coordSS);

    // Position
    PositionInputs posInput = GetPositionInput(coordSS.xy, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V, uint2(0, 0));
    float3 positionWS = posInput.positionWS;
    float cascadeIndex = ComputeCascadeIndex(positionWS);
    float4 shadowCoord = mul(_MainLightWorldToShadow[cascadeIndex], float4(positionWS, 1.0));

    float radial2ShadowmapDepth = _PerCascadePCSSData[cascadeIndex].x;
    float texelSizeWS           = _PerCascadePCSSData[cascadeIndex].y;
    float farToNear             = _PerCascadePCSSData[cascadeIndex].z;
    float blockerInvTangent     = _PerCascadePCSSData[cascadeIndex].w;

    // Sample Noise: Use Jitter instead.
    float2 noiseJitter = 0;
    noiseJitter.xy = InterleavedGradientNoise(coordSS.xy, _STBNIndex);
    noiseJitter *= TWO_PI;
    noiseJitter.x = sin(noiseJitter.x);
    noiseJitter.y = cos(noiseJitter.y);


    // Blocker Search
    float filterSize = FILTER_SIZE_BLOCKER / texelSizeWS; // texel count
    filterSize = max(filterSize, 1.0);
    float2 avgDepthAndCount = BlockerSearch(BLOCKER_SAMPLE_COUNT, filterSize, shadowCoord.xyz, noiseJitter, cascadeIndex);
    if (avgDepthAndCount.y == 0) // No Blocker
    {
        _PCSSTexture[coordSS] = 1.0;
        return;
    }

    // Penumbra Estimation
    float blockerDistance = abs(avgDepthAndCount.x - shadowCoord.z);
    blockerDistance *= farToNear;
    blockerDistance = min(blockerDistance, 10.0);

    float maxPCSSoffset = blockerDistance / farToNear * 0.25;

    float pcssFilterSize = DIR_LIGHT_PENUMBRA_WIDTH * blockerDistance * 0.01 / texelSizeWS;
    pcssFilterSize = max(pcssFilterSize, 0.01);


    // PCSS Filter
    float pcssResult = PCSSFilter(PCSS_SAMPLE_COUNT, pcssFilterSize, shadowCoord.xyz, noiseJitter, cascadeIndex, maxPCSSoffset);
    

    _PCSSTexture[coordSS] = pcssResult;

}

#elif defined(SHADOW_BILATERAL_FILTER)
//--------------------------------------------------------------------------------------------------
// Implementation Bilateral Filter
//--------------------------------------------------------------------------------------------------

groupshared float4 localNormalDepth[256];
groupshared float localColor[256];

struct CoordData {
    float3  normal;
    float   depth;
    float   color;
};


#define GAUSSIAN_WEIGHT_COUNT (9)
static const float gaussianWeight[GAUSSIAN_WEIGHT_COUNT] = {0.02763055, 0.06628224, 0.1238315, 0.1801738, 0.2041637, 0.1801738, 0.1238315, 0.06628224, 0.02763055};

struct BilateralData
{
    float3 position;
    float depth;
    float3 normal;
};

float GetEdegStoppingNormalWeight(float3 normal1, float3 normal2)
{
    return pow(max(dot(normal1, normal2), 0.0f), 32.0f);
}

float GetEdgeStoppingDepthWeight(float centerDepth, float neighDepth)
{
    return exp(-abs(centerDepth - neighDepth) * 4.0);
}

// TODO: Actually we should use plane base depth weight like SVGF.
float ComputeBilateralWeight(BilateralData center, BilateralData neigh)
{
    // Depth
    float depthWeight = GetEdgeStoppingDepthWeight(center.depth, neigh.depth);

    // Normal
    float normalWeight = GetEdegStoppingNormalWeight(center.normal, neigh.normal);

    return depthWeight * normalWeight;
}

CoordData LoadFromGroupSharedMemory(uint2 gThreadId)
{
    #if FINAL_PASS
    gThreadId.y += 4;
    #else
    gThreadId.x += 4;
    #endif

    uint localID = gThreadId.x + 16 * gThreadId.y;
    float4 encodedNormalDepth = localNormalDepth[localID];

    CoordData neighborSample;
    ZERO_INITIALIZE(CoordData, neighborSample);
    neighborSample.normal = encodedNormalDepth.xyz;
    neighborSample.depth = encodedNormalDepth.w;
    neighborSample.color = localColor[localID];
    
    return neighborSample;
}

void StoreInGroupSharedMemory(uint2 gThreadId, CoordData inData)
{
    #if FINAL_PASS
    gThreadId.y += 4;
    #else
    gThreadId.x += 4;
    #endif

    uint localID = gThreadId.x + 16 * gThreadId.y;
    localNormalDepth[localID] = float4(inData.normal.xyz, inData.depth);
    localColor[localID] = inData.color;
}

void LoadCoordData(int2 coordSS, out CoordData outData)
{
    ZERO_INITIALIZE(CoordData, outData);
    if (coordSS.x >= _ScreenSize.x || coordSS.y >= _ScreenSize.y || coordSS.x < 0.0 || coordSS.y < 0.0)
    {
        outData.depth = UNITY_RAW_FAR_CLIP_VALUE;
        return;
    }

    float deviceDepth = LoadSceneDepth(coordSS);
    if (deviceDepth == UNITY_RAW_FAR_CLIP_VALUE)
    {
        outData.depth = UNITY_RAW_FAR_CLIP_VALUE;
        return;
    }

    float4 normalGBuffer = LOAD_TEXTURE2D_X(_GBuffer2, coordSS);
    float3 normalWS = normalize(UnpackNormal(normalGBuffer.xyz));

    outData.normal = normalWS;
    outData.depth = LinearEyeDepth(deviceDepth, _ZBufferParams);
    outData.color = _BilateralTexture[coordSS];
}

void InitializeGroupSharedMemory(uint2 dThreadId, uint2 gThreadId)
{
    #if FINAL_PASS
    uint2 offset[2] = {uint2(0, -4), uint2(0, 4)};
    #else
    uint2 offset[2] = {uint2(-4, 0), uint2(4, 0)};
    #endif

    CoordData coordData[2];
    for (int i = 0; i < 2; i++)
    {
        LoadCoordData(dThreadId + offset[i], coordData[i]);
    }

    for (int j = 0; j < 2; j++)
    {
        StoreInGroupSharedMemory(gThreadId + offset[j], coordData[j]);
    }
}


[numthreads(SCREENSPACE_SHADOWS_GROUP_SIZE, SCREENSPACE_SHADOWS_GROUP_SIZE, 1)]
void BILATERAL_FILTER(uint3 dispatchThreadId : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID, uint groupId : SV_GroupID)
{
    uint2 coordSS;
    uint2 tileCoord;
    InitializeDispatchThreadIdFromTileList(groupId, groupThreadId, tileCoord, coordSS);

    uint2 coordGroup = groupThreadId.xy;
    InitializeGroupSharedMemory(coordSS, coordGroup);

    GroupMemoryBarrierWithGroupSync();

    CoordData center = LoadFromGroupSharedMemory(coordGroup);
    float2 screenUV = coordSS * _ScreenSize.zw + (0.5 * _ScreenSize.zw);

    if (center.depth == UNITY_RAW_FAR_CLIP_VALUE)
        return;

    // Position
    PositionInputs posInput = GetPositionInput(coordSS.xy, _ScreenSize.zw, center.depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V, uint2(0, 0));

    BilateralData centerData;
    ZERO_INITIALIZE(BilateralData, centerData);
    {
        centerData.normal = center.normal;
        centerData.depth = center.depth;
    }


    float colorSum = center.color * gaussianWeight[4];
    float weightSum = gaussianWeight[4];

    // TODO: Actually far distance pixels should have smaller radius.
    int radius = 4;

    #if FINAL_PASS
        const int2 passIncr = int2(0, 1);
    #else
        const int2 passIncr = int2(1, 0);
    #endif

    int2 neighCoordGroup = coordGroup - radius * passIncr;
    for (int r = -radius; r <= radius; r++, neighCoordGroup += passIncr)
    {
        if (r == 0)
            continue;
        CoordData neigh = LoadFromGroupSharedMemory(neighCoordGroup);
        if (neigh.depth == UNITY_RAW_FAR_CLIP_VALUE)
            continue;

        BilateralData neighData;
        ZERO_INITIALIZE(BilateralData, neighData);
        {
            neighData.normal = neigh.normal;
            neighData.depth = neigh.depth;
        }

        float bilateralWeight = ComputeBilateralWeight(centerData, neighData);
        float weight = gaussianWeight[r + 4] * bilateralWeight;

        colorSum += weight * neigh.color;
        weightSum += weight;
    }

    _BilateralTexture[coordSS] = colorSum / weightSum;
}

#endif